# MPCæ–¹æ³•å®žçŽ°Double-gyre flowæ™ºèƒ½ä½“è·¯å¾„è§„åˆ’



## 1 å®žçŽ°æ–¹æ³•

### 1.1 å®žçŽ°å·¥å…·

é‡‡ç”¨é›†æˆåœ¨Pythonè¯­è¨€çŽ¯å¢ƒä¸­çš„**Casadi**å·¥å…·åŒ…å®žçŽ°MPCæŽ§åˆ¶æ–¹æ³•ï¼›CasADi æ˜¯ä¸€ä¸ªç”¨äºŽä¼˜åŒ–å’Œè‡ªåŠ¨å¾®åˆ†çš„å·¥å…·åŒ…ï¼Œç‰¹åˆ«é€‚ç”¨äºŽåŠ¨æ€ç³»ç»Ÿçš„ä»¿çœŸå’ŒæŽ§åˆ¶ã€‚

Casadiå·¥å…·åŒ…çš„ä¸»è¦ç”¨é€”ï¼š

**ç¬¦å·è®¡ç®—ï¼š**æ”¯æŒç¬¦å·è¡¨è¾¾å¼å’ŒçŸ©é˜µçš„å®šä¹‰å’Œæ“ä½œï¼Œèƒ½å¤Ÿè‡ªåŠ¨æ±‚å¯¼ï¼Œé€‚ç”¨äºŽéœ€è¦ç²¾ç¡®å¯¼æ•°çš„åº”ç”¨åœºæ™¯ã€‚

**è‡ªåŠ¨å¾®åˆ†ï¼š**CasADi æä¾›äº†å‰å‘å’Œåå‘æ¨¡å¼çš„è‡ªåŠ¨å¾®åˆ†åŠŸèƒ½ï¼Œè¿™ä½¿å¾—åœ¨ä¼˜åŒ–è¿‡ç¨‹ä¸­è®¡ç®—å¯¼æ•°æ›´åŠ é«˜æ•ˆã€‚

**ä¼˜åŒ–æ±‚è§£ï¼š**æ”¯æŒå„ç§ç±»åž‹çš„ä¼˜åŒ–é—®é¢˜ï¼ŒåŒ…æ‹¬éžçº¿æ€§è§„åˆ’ï¼ˆNLPï¼‰ï¼ŒäºŒæ¬¡è§„åˆ’ï¼ˆQPï¼‰ï¼Œä»¥åŠå¸¦æœ‰çº¦æŸçš„æœ€ä¼˜æŽ§åˆ¶é—®é¢˜ï¼ˆOCPï¼‰ã€‚

**æ•°å€¼æ±‚è§£å™¨ï¼š**å†…ç½®äº†å¤šç§æ•°å€¼æ±‚è§£å™¨ï¼Œå¯ä»¥ç”¨äºŽæ±‚è§£å¸¸å¾®åˆ†æ–¹ç¨‹ï¼ˆODEï¼‰ï¼Œå¾®åˆ†ä»£æ•°æ–¹ç¨‹ï¼ˆDAEï¼‰ç­‰ã€‚



### 1.2 å®žçŽ°æ–¹æ³•

**å•å°„æ³•ï¼ˆsingle-shootingï¼‰**æ˜¯ä¸€ç§æ±‚è§£æœ€ä¼˜æŽ§åˆ¶é—®é¢˜çš„æ•°å€¼æ–¹æ³•ã€‚é€šè¿‡å°†æ•´ä¸ªæ—¶é—´åŒºé—´ç¦»æ•£åŒ–ï¼Œå¹¶å°†æœ€ä¼˜æŽ§åˆ¶é—®é¢˜è½¬åŒ–ä¸ºä¸€ä¸ªéžçº¿æ€§è§„åˆ’ï¼ˆNLPï¼‰é—®é¢˜æ¥æ±‚è§£ã€‚

å®žçŽ°è¿‡ç¨‹

**1ã€åˆå§‹æ¡ä»¶å®šä¹‰**

åˆå§‹çŠ¶æ€ï¼šå®šä¹‰ç³»ç»Ÿåœ¨åˆå§‹æ—¶é—´ç‚¹çš„çŠ¶æ€ 
$$
x(t0)=x0
$$
ä¸ºå·²çŸ¥çš„åˆå§‹æ¡ä»¶ã€‚

**2ã€æŽ§åˆ¶å˜é‡å®šä¹‰**

æŽ§åˆ¶è¾“å…¥ï¼šåœ¨æ•´ä¸ªæ—¶é—´åŒºé—´å†…å®šä¹‰æŽ§åˆ¶è¾“å…¥utã€‚åœ¨å•å°„æ³•ä¸­ï¼ŒæŽ§åˆ¶è¾“å…¥é€šå¸¸åœ¨æ¯ä¸ªæ—¶é—´æ­¥å†…ä¿æŒä¸å˜ã€‚

**3ã€æ—¶é—´ç¦»æ•£åŒ–**

æ—¶é—´ç½‘æ ¼ï¼šå°†è¿žç»­æ—¶é—´[t0,tf]è¿›è¡Œç¦»æ•£ã€‚

**4ã€åŠ¨æ€æ›´æ–°**

æ•°å€¼ç§¯åˆ†ï¼šä½¿ç”¨æ•°å€¼ç§¯åˆ†æ–¹æ³•åœ¨æ¯ä¸ªæ—¶é—´æ­¥ä¸Šæ±‚è§£çŠ¶æ€æ–¹ç¨‹ï¼Œå¯¹çŠ¶æ€å˜é‡è¿›è¡Œæ›´æ–°ã€‚

**5ã€ä¼˜åŒ–ç›®æ ‡**

ç›®æ ‡å‡½æ•°ï¼šå®šä¹‰ä¸€ä¸ªç›®æ ‡å‡½æ•°

![image-20240805163923344](C:\Users\LENOVO\AppData\Roaming\Typora\typora-user-images\image-20240805163923344.png)

è¯¥ç›®æ ‡å‡½æ•°ç”±è¿è¡Œæˆæœ¬å’Œç»ˆç«¯æˆæœ¬ä¸¤éƒ¨åˆ†ç»„æˆï¼Œè¿è¡Œæˆæœ¬åœ¨æ¯æ­¥æ›´æ–°æ—¶ç´¯åŠ ï¼Œç»ˆç«¯æˆæœ¬åæ˜ æœ«çŠ¶æ€å’ŒæœŸæœ›çŠ¶æ€çš„å…³ç³»ã€‚

**6ã€çº¦æŸæ¡ä»¶**

åœ¨é—®é¢˜æž„å»ºè¿‡ç¨‹ä¸­ï¼ŒçŠ¶æ€å˜é‡å’ŒæŽ§åˆ¶å˜é‡çš„å€¼è¦åœ¨ä¸€å®šçš„èŒƒå›´å†…è¢«çº¦æŸã€‚

**7ã€æ±‚è§£éžçº¿æ€§è§„åˆ’é—®é¢˜**

**ä¼˜åŒ–å™¨**ï¼šå°†æ•´ä¸ªé—®é¢˜è½¬åŒ–ä¸ºä¸€ä¸ª NLP é—®é¢˜ï¼Œæ±‚è§£æœ€ä¼˜çš„æŽ§åˆ¶è¾“å…¥åºåˆ— u(t)ï¼Œä½¿ç”¨ä¼˜åŒ–æ±‚è§£å™¨ï¼ˆå¦‚ IPOPTï¼‰æ¥æ±‚è§£è¿™ä¸ª NLP é—®é¢˜ã€‚



## 2 å®žçŽ°è¿‡ç¨‹

### 2.1 åŠ¨æ€æ›´æ–°æ¨¡åž‹å»ºç«‹

åœ¨Casadiè¯­è¨€çŽ¯å¢ƒä¸‹ï¼Œå»ºç«‹æ™ºèƒ½ä½“åœ¨Double-gyre flowä¸­çš„çŠ¶æ€æ›´æ–°æ¨¡åž‹ï¼Œç†è®ºä¾æ®æ¥è‡ªæ–‡çŒ®ï¼š

[1]Mei J, Kutz J N, Brunton S L. Observability-Based Energy Efficient Path Planning with Background Flow via Deep Reinforcement Learning[C]//2023 62nd IEEE Conference on Decision and Control (CDC). IEEE, 2023: 4364-4371.

[2]Gunnarson P, Mandralis I, Novati G, et al. Learning efficient navigation in vortical flow fields[J]. Nature communications, 2021, 12(1): 7143.



Double-gyre flowæµåœºé€Ÿåº¦åœ¨æ–‡çŒ®[2]ä¸­å®šä¹‰ï¼š
$$
ðœ“(ð‘¥,ð‘¦,ð‘¡) = ð´sin(ðœ‹ ð‘“ (ð‘¥,ð‘¡))sin(ðœ‹ð‘¦)
$$

$$
ð‘“ (ð‘¥,ð‘¡) = ðœ– sin(ðœ”ð‘¡)ð‘¥2 +ð‘¥âˆ’2ðœ–sin(ðœ”ð‘¡)ð‘¥
$$

$$
Uflow = v(ð‘¥,ð‘¦,ð‘¡)=[âˆ’ðœ•ðœ“/ðœ•y,ðœ•ðœ“/ðœ•x]=[âˆ’ðœ‹ð´sin(ðœ‹ð‘“(ð‘¥,ð‘¡))cos(ðœ‹ð‘¦), âˆ’ðœ‹ð´cos(ðœ‹ð‘“ (ð‘¥,ð‘¡))sin(ðœ‹ð‘¦)ð‘‘ð‘“/ð‘‘ð‘¡]
$$

å…¶ä¸­ï¼Œ ð´ = 0.5,ðœ” = 2ðœ‹,ðœ– = 0.25ä¸ºè®ºæ–‡ä¸­ä½¿ç”¨çš„å‚æ•°ã€‚

æ™ºèƒ½ä½“çš„è¿åŠ¨å…¬å¼åœ¨æ–‡çŒ®[1]ä¸­å®šä¹‰:
$$
X0=Xstart
$$

$$
Xn+1=Xn + Î”t(Uswim[cos(Î¸),sin(Î¸)]+Uflow)
$$



æ ¹æ®ä¸Šè¿°å…¬å¼ï¼Œåœ¨Casadiçš„ç¬¦å·è¯­è¨€çŽ¯å¢ƒä¸‹ç¼–å†™ä»£ç æ®µï¼š

```
# åŠ¨åŠ›å­¦å‡½æ•°
def f_1(pos_x, t):
    """

    param pos_x:          position x
    param t:        simulation time

    return: f(x,t)
    """
    out_put = epsilon * ca.sin(omega * t) * pos_x ** 2 + pos_x - 2 * epsilon * ca.sin(omega * t) * pos_x
    return out_put

def psi(pos_x, pos_y, t):
    """

    param pos_x:          position x
    param pos_y:          position y
    param t:        simulation time

    return: Ïˆ(x,y,t)
    """

    out_put = A * ca.sin(ca.pi * f_1(pos_x, t)) * ca.sin(ca.pi * pos_y)
    return out_put

def U_flow_x(pos_x, pos_y, t):
    """

    param pos_x:          position x
    param pos_y:          position y
    param t:        simulation time

    return: vflow_x
    """

    out_put = -ca.pi * A * ca.sin(ca.pi * f_1(pos_x, t)) * ca.cos(ca.pi * pos_y)
    return out_put

def U_flow_y(pos_x, pos_y, t):
    """

    param pos_x:          position x
    param pos_y:          position y
    param t:        simulation time

    return: vflow_y
    """

    out_put = ca.pi * A * ca.cos(ca.pi * f_1(pos_x, t)) * ca.sin(ca.pi * pos_y) * (
            2 * epsilon * ca.sin(omega * t) * pos_x
            + 1 - 2 * epsilon * ca.sin(omega * t))
    return out_put
   
def agent_dynamics_withtime(state_init, control_init):
    action = control_init
    pos_x, pos_y, pos_t = state_init[0], state_init[1], state_init[2]
    v_flow_x = U_flow_x(pos_x, pos_y, pos_t)
    v_flow_y = U_flow_y(pos_x, pos_y, pos_t)

    delta_pos_x = U_swim * ca.cos(action) + v_flow_x
    delta_pos_y = U_swim * ca.sin(action) + v_flow_y
    delta_t = 1
    return ca.vertcat(delta_pos_x, delta_pos_y, delta_t)
```

åœ¨Casadiçš„è¯­è¨€çŽ¯å¢ƒä¸‹ï¼Œ

```
sin cos pi
```

éœ€å†™ä¸º

```
ca.sin ca.cos ca.pi
```

'agent_dynamics_withtime' å®šä¹‰äº†æ™ºèƒ½ä½“çš„çŠ¶æ€å˜åŒ–ï¼Œæ™ºèƒ½ä½“åŒ…å«3ä¸ªçŠ¶æ€å˜é‡xã€yã€tä»¥åŠä¸€ä¸ªæŽ§åˆ¶å˜é‡Î¸ã€‚



### 2.2 CasadiçŽ¯å¢ƒä¸‹å®šä¹‰MPCé—®é¢˜å’Œæ±‚è§£å™¨

#### 2.2.1 çŽ¯å¢ƒå˜é‡å£°æ˜Ž

è¯¥éƒ¨åˆ†ä¸»è¦å£°æ˜Žåœ¨MPCæ–¹æ³•è¿‡ç¨‹ä¸­éœ€è¦çš„å‚æ•°ï¼ŒåŒ…æ‹¬é‡‡æ ·æ›´æ–°æ—¶é—´Î”tã€MPCæ–¹æ³•éœ€è¦é¢„æµ‹çš„æ­¥æ•°Nä»¥åŠå¼€å§‹çš„æ—¶é—´ç‚¹t0ã€‚

```
dt = 0.1  # ï¼ˆæ¨¡æ‹Ÿçš„ï¼‰ç³»ç»Ÿé‡‡æ ·æ—¶é—´ã€ç§’ã€‘
N = 10  # éœ€è¦é¢„æµ‹çš„æ­¥é•¿ã€è¶…å‚æ•°ã€‘
t0 = 0  # åˆå§‹æ—¶é—´
```

å…¶ä¸­ï¼ŒNæ˜¯MPCè¿‡ç¨‹ä¸­å¯ä»¥è°ƒèŠ‚çš„å˜é‡ï¼Œè¡¨ç¤ºâ€œä¹‹åŽNæ­¥çš„â€æŽ§åˆ¶è¾“å‡º



#### 2.2.2 CasadiæŽ§åˆ¶é—®é¢˜å»ºæ¨¡

åœ¨è¯¥éƒ¨åˆ†é€šè¿‡ç¬¦å·Casadiä½¿ç”¨è§„èŒƒçš„æ–¹å¼ï¼Œæž„å»ºäº†ä¸€ä¸ªåŒ…å«çŠ¶æ€ã€æŽ§åˆ¶è¾“å…¥å’Œæ›´æ–°æ–¹æ³•çš„æŽ§åˆ¶é—®é¢˜ã€‚

```
# 1 ç³»ç»ŸçŠ¶æ€
x = ca.SX.sym('x')  # xåæ ‡
y = ca.SX.sym('y')  # yåæ ‡
t = ca.SX.sym('time')  # æ—¶é—´æ­¥
states = ca.vertcat(x, y, t)
n_states = states.size()[0]  # èŽ·å¾—ç³»ç»ŸçŠ¶æ€çš„å°ºå¯¸ï¼Œå‘é‡ä»¥ï¼ˆn_states, 1ï¼‰çš„æ ¼å¼å‘ˆçŽ°

# 2 æŽ§åˆ¶è¾“å…¥
theta = ca.SX.sym('theta')
controls = ca.vertcat(theta)
n_controls = controls.size()[0]  # æŽ§åˆ¶å‘é‡å°ºå¯¸

# 3 è¿åŠ¨å­¦æ¨¡åž‹
# å®šä¹‰å³æ‰‹å‡½æ•°
rhs = agent_dynamics_withtime(states, controls)
# åˆ©ç”¨CasADiæž„å»ºä¸€ä¸ªå‡½æ•°
f = ca.Function('f', [states, controls], [rhs], ['input_state', 'control_input'], ['rhs'])
```

åœ¨Casadiçš„è¯­è¨€çŽ¯å¢ƒä¸‹ï¼ŒSXå’ŒMXæ˜¯ä¸¤ç§ç±»åž‹çš„ç¬¦å·çŸ©é˜µï¼š

**SX**ï¼šé€‚ç”¨äºŽç¨€ç–ç¬¦å·çŸ©é˜µï¼ˆSparse Matrix of Symbolic Expressionsï¼‰ã€‚ç”¨äºŽé‚£äº›ç¨€ç–ç»“æž„æ˜Žç¡®çš„ç¬¦å·è®¡ç®—ï¼Œé€‚åˆè¾ƒå°è§„æ¨¡ä¸”ç»“æž„å›ºå®šçš„é—®é¢˜ã€‚å…·æœ‰è¾ƒé«˜çš„è¯„ä¼°æ•ˆçŽ‡ï¼Œä½†åœ¨ç¬¦å·æ“ä½œå’Œå¤§è§„æ¨¡è®¡ç®—æ—¶å¯èƒ½ä¸å¦‚é«˜æ•ˆã€‚

**MX**ï¼šé€‚ç”¨äºŽæ›´å¤æ‚å’Œæ›´é€šç”¨çš„ç¬¦å·çŸ©é˜µï¼ˆMatrix of Symbolic Expressionsï¼‰å…è®¸ç¨€ç–å’Œå¯†é›†ç»“æž„ï¼Œå¹¶ä¸”åœ¨ç¬¦å·æ“ä½œï¼ˆå¦‚æ±‚å¯¼å’Œç®€åŒ–ï¼‰ä¸Šæ›´åŠ çµæ´»å’Œé«˜æ•ˆã€‚é€‚ç”¨äºŽå¤§è§„æ¨¡ã€ç»“æž„å¤æ‚çš„ä¼˜åŒ–å’Œä»¿çœŸé—®é¢˜ã€‚



```
f = ca.Function('f', [states, controls], [rhs], ['input_state', 'control_input'], ['rhs'])
```

å®šä¹‰äº†ä¸€ä¸ªç¬¦å·å‡½æ•°æ˜ å°„å…³ç³»ï¼Œå‡½æ•°åç§°'f'ï¼Œè¾“å…¥å˜é‡[states, controls]ï¼Œæ˜ å°„åˆ°çš„å³æ‰‹å‡½æ•°åœ¨rhsæ–¹æ³•ä¸­å®šä¹‰ã€‚



#### 2.2.3 MPCé—®é¢˜æž„å»º

è¯¥éƒ¨åˆ†å¯¹MPCé—®é¢˜è¿›è¡Œäº†æž„å»ºï¼ŒMPCé—®é¢˜é¢„æµ‹æŸä¸€æ—¶é—´æ­¥çŠ¶æ€åŽæ•°ä¸ªæ—¶é—´æ­¥çš„è¿åŠ¨çŠ¶æ€æ›´æ–°è¿‡ç¨‹ã€‚

**ç›¸å…³å˜é‡æž„å»º**

```
ç›¸å…³å˜é‡ï¼Œæ ¼å¼ä¸º(çŠ¶æ€é•¿åº¦ï¼Œ æ­¥é•¿)
U = ca.SX.sym('U', n_controls, N)  # Næ­¥å†…çš„æŽ§åˆ¶è¾“å‡º
X = ca.SX.sym('X', n_states, N + 1)  # N+1æ­¥çš„ç³»ç»ŸçŠ¶æ€ï¼Œé€šå¸¸é•¿åº¦æ¯”æŽ§åˆ¶å¤š1
P = ca.SX.sym('P', n_states + n_states)  # æž„å»ºé—®é¢˜çš„ç›¸å…³å‚æ•°,åœ¨è¿™é‡Œæ¯æ¬¡åªéœ€è¦ç»™å®šå½“å‰/åˆå§‹ä½ç½®å’Œç›®æ ‡ç»ˆç‚¹ä½ç½®
```

Uå’ŒXåŒ…å«N/N+1ä¸ªåŠ¨ä½œä¿¡æ¯/çŠ¶æ€ä¿¡æ¯ã€Pè®°å½•é¢„æµ‹åˆå§‹ä½ç½®çš„ä¿¡æ¯å’Œç›®æ ‡ç»ˆç‚¹çš„ä¿¡æ¯ã€‚



**æ›´æ–°æ–¹å¼æž„å»º**

```
Single Shooting çº¦æŸæ¡ä»¶
X[:, 0] = P[:n_states]
```

ä¼˜åŒ–è¿‡ç¨‹ä¸­ï¼Œå°†çŠ¶æ€å˜é‡çš„ç¬¬ä¸€ä¸ªå€¼ï¼ˆåˆå€¼ï¼‰èµ‹äºˆPï¼ŒPçš„åŽä¸‰ä¸ªå€¼ä¸ºç›®æ ‡ç»ˆç‚¹çš„å€¼ï¼Œä¸æ”¹å˜ã€‚

ä¹‹åŽé€šè¿‡Uä¸­çš„æŽ§åˆ¶å˜é‡å¯¹Xä¸­çš„å†…å®¹è¿›è¡Œæ›´æ–°ï¼š

```
#å‰©ä½™NçŠ¶æ€çº¦æŸæ¡ä»¶
for i in range(N):
    # é€šè¿‡å‰è¿°å‡½æ•°èŽ·å¾—ä¸‹ä¸ªæ—¶åˆ»ç³»ç»ŸçŠ¶æ€å˜åŒ–ã€‚
    # è¿™é‡Œéœ€è¦æ³¨æ„å¼•ç”¨çš„indexä¸º[:, i]ï¼Œå› ä¸ºXä¸º(n_states, N+1)çŸ©é˜µ
    delta_X = f(X[:, i], U[:, i])  # delta_X
    X[:, i + 1] = X[:, i] + delta_X * dt
```

```
# èŽ·å¾—è¾“å…¥ï¼ˆæŽ§åˆ¶è¾“å…¥ï¼Œå‚æ•°ï¼‰å’Œè¾“å‡ºï¼ˆç³»ç»ŸçŠ¶æ€ï¼‰ä¹‹é—´å…³ç³»çš„å‡½æ•°ff
ff = ca.Function('ff', [U, P], [X], ['input_U', 'target_state'], ['horizon_states'])
```

å‡½æ•°å'ff'ï¼Œè¾“å…¥Uå’ŒPï¼Œè¾“å‡ºä¸ºX



**NLPé—®é¢˜çš„ä¼˜åŒ–ç›®æ ‡æž„å»º**

```
# NLPé—®é¢˜
# ä½ç½®æƒ©ç½šçŸ©é˜µ
Q = np.zeros((2, 2))  # å…¨é›¶ 2x2 çŸ©é˜µï¼Œç”¨äºŽæƒ©ç½šä½ç½®
Q[:2, :2] = np.array([[10.0, 0.0],  # å¯¹çŠ¶æ€çŸ©é˜µçš„å‰ä¸¤ä¸ªè¿›è¡Œæƒ©ç½š
                      [0.0, 10.0]])
# æ—¶é—´æƒ©ç½šçŸ©é˜µ
R = np.array([10.0])
# ä¼˜åŒ–ç›®æ ‡
obj = 0  # åˆå§‹åŒ–ä¼˜åŒ–ç›®æ ‡å€¼
for i in range(N):
    # åœ¨Næ­¥å†…å¯¹èŽ·å¾—ä¼˜åŒ–ç›®æ ‡è¡¨è¾¾å¼
    # .Tè¡¨ç¤ºçŸ©é˜µè½¬ç½®,è®¡ç®—æƒ©ç½šå‡½æ•° å¯¹åº”è¯¯å·®çš„å¹³æ–¹ä¸Žç³»æ•°ç›¸ä¹˜å†ç›¸åŠ 
    # ca.mtimes,çŸ©é˜µä¹˜æ³•æ“ä½œ
    obj = obj + ca.mtimes([(X[:2, i] - P[n_states:-1]).T, Q, X[:2, i] - P[n_states:-1]]) + \
          ca.mtimes([X[-1, i].T, R, X[-1, i]])
```

é€šè¿‡çŸ©é˜µä¹˜æ³•çš„å½¢å¼æ¥æž„å»ºä½ç½®ä¼˜åŒ–ç›®æ ‡ï¼Œç›®æ ‡ä¸ºä¸Žç›®æ ‡ç»ˆç‚¹è§£å†³ï¼›é€šè¿‡æƒ©ç½šæ—¶é—´çŠ¶æ€çš„å€¼æ¥èµ·åˆ°ç¼©çŸ­è¿è¡Œæ—¶é—´çš„ç›®çš„ã€‚



**çŠ¶æ€å˜é‡çš„çº¦æŸæ¡ä»¶å®šä¹‰**

```
# çº¦æŸæ¡ä»¶å®šä¹‰
g = []  # ç”¨listæ¥å­˜å‚¨ä¼˜åŒ–ç›®æ ‡çš„å‘é‡
for i in range(N + 1):
    # è¿™é‡Œçš„çº¦æŸæ¡ä»¶åªæœ‰å°è½¦çš„åæ ‡ï¼ˆx,yï¼‰å¿…é¡»åœ¨-2è‡³2ä¹‹é—´
    # ç”±äºŽxyæ²¡æœ‰ç‰¹å¼‚æ€§ï¼Œæ‰€ä»¥åœ¨è¿™ä¸ªä¾‹å­ä¸­é¡ºåºä¸é‡è¦ï¼ˆä½†æ˜¯åœ¨æ›´å¤šå®žä¾‹ä¸­ï¼Œè¿™ä¸ªå¾ˆé‡è¦ï¼‰
    # gä¸­è¡¨ç¤ºéœ€è¦çº¦æŸçš„å†…å®¹
    # g.append(X[0, i])  # ç¬¬ä¸€è¡Œç¬¬nåˆ—
    # g.append(X[1, i])  # ç¬¬äºŒè¡Œç¬¬nåˆ—
    pass
```

å®Œæˆä¸Šè¿°æ“ä½œåŽï¼Œå¾—åˆ°NLPé—®é¢˜çš„ä¼˜åŒ–å€¼å‡½æ•°

```
# å®šä¹‰NLPé—®é¢˜ï¼Œ'f'ä¸ºéœ€è¦ä¼˜åŒ–çš„ç›®æ ‡å‡½æ•°ï¼Œ'x'ä¸ºéœ€è¦ä¼˜åŒ–çš„ç›®æ ‡å˜é‡ï¼Œ'p'ä¸ºåŒ…å«å·²çŸ¥ä¸å˜çš„å‚æ•°ï¼Œ'g'ä¸ºé¢å¤–çº¦æŸæ¡ä»¶
# éœ€è¦æ³¨æ„çš„æ˜¯ï¼Œç”¨SXè¡¨è¾¾å¿…é¡»å°†æ‰€æœ‰è¡¨ç¤ºæˆæ ‡é‡æˆ–è€…æ˜¯ä¸€ç»´çŸ¢é‡çš„å½¢å¼
nlp_prob = {'f': obj, 'x': ca.reshape(U, -1, 1), 'p': P, 'g': ca.vertcat(*g)}# .reshape(U, -1, 1):-1 è¡¨ç¤ºè¯¥ç»´åº¦å¤§å°ç”±å¦ä¸€ç»´åº¦æŽ¨æ¼”å¾—åˆ°, 1 ä¸€åˆ—
```

å®šä¹‰NLPé—®é¢˜ï¼Œ'f'ä¸ºéœ€è¦ä¼˜åŒ–çš„ç›®æ ‡å‡½æ•°ï¼Œ'x'ä¸ºéœ€è¦ä¼˜åŒ–çš„ç›®æ ‡å˜é‡ï¼Œ'p'ä¸ºåŒ…å«å·²çŸ¥ä¸å˜çš„å‚æ•°ï¼Œ'g'ä¸ºé¢å¤–çº¦æŸæ¡ä»¶ã€‚åˆ†åˆ«å¯¹åº”objã€æŽ§åˆ¶å˜é‡Uã€å›ºå®šè®°å½•På’Œçº¦æŸg



#### 2.2.4 æ±‚è§£å™¨è®¾ç½®

é‡‡ç”¨'ipoptæ–¹æ³•'ä½œä¸ºMPCæŽ§åˆ¶é—®é¢˜çš„æ±‚è§£å™¨ã€‚**IPOPTï¼ˆInterior Point OPTimizerï¼‰**ä½¿ç”¨çš„æ˜¯å†…ç‚¹æ³•ï¼ˆInterior Point Methodï¼‰æ¥æ±‚è§£å…·æœ‰éžçº¿æ€§ç›®æ ‡å‡½æ•°å’Œéžçº¿æ€§çº¦æŸçš„ä¼˜åŒ–é—®é¢˜ã€‚å†…ç‚¹æ³•çš„æ ¸å¿ƒæ€æƒ³æ˜¯é€šè¿‡å¼•å…¥æ¾å¼›å˜é‡ï¼Œå°†ä¸ç­‰å¼çº¦æŸè½¬åŒ–ä¸ºç­‰å¼çº¦æŸï¼Œå¹¶ä¸”é€æ­¥ç¼©å°è¿™äº›æ¾å¼›å˜é‡ï¼Œä½¿è§£é€æ¸æŽ¥è¿‘å¯è¡ŒåŸŸçš„è¾¹ç•Œã€‚

IPOPTæ–¹æ³•çš„æ ¸å¿ƒæ˜¯å°†åŽŸå§‹é—®é¢˜è½¬åŒ–ä¸ºä¸€ä¸ªæ— çº¦æŸçš„é—®é¢˜ï¼Œé€šè¿‡å¼•å…¥éšœç¢å‡½æ•°ï¼š
$$
Ï•(x,Î¼)=f(x)âˆ’Î¼ âˆ‘ln(si)
$$
å…¶ä¸­Î¼ æ˜¯éšœç¢å‚æ•°ï¼Œéšç€è¿­ä»£è¿›è¡Œé€æ¸å‡å°ã€‚si æ˜¯æ¾å¼›å˜é‡ï¼Œæ»¡è¶³ si>0ã€‚

IPOPTçš„æ–¹æ³•çš„é¡ºåºå¦‚ä¸‹ï¼š

1ã€**åˆå§‹åŒ–**ï¼šé€‰æ‹©åˆå§‹è§£ x0ã€æ¾å¼›å˜é‡ s0å’Œéšœç¢å‚æ•° Î¼0ã€‚

2ã€**KKT æ¡ä»¶**ï¼šæ±‚è§£ Karush-Kuhn-Tucker (KKT) æ¡ä»¶ï¼Œè¿™äº›æ¡ä»¶åŒ…æ‹¬äº†ç›®æ ‡å‡½æ•°çš„æ¢¯åº¦ã€ç­‰å¼çº¦æŸå’Œä¸ç­‰å¼çº¦æŸçš„æ¢¯åº¦ï¼Œä»¥åŠæ¾å¼›å˜é‡å’Œçº¦æŸçš„äº’è¡¥æ¡ä»¶ã€‚

3ã€**ç‰›é¡¿æ³•**ï¼šä½¿ç”¨ä¿®æ­£çš„ç‰›é¡¿æ³•æ¥è§£å†³ KKT ç³»ç»Ÿï¼Œé€šè¿‡çº¿æ€§åŒ–çš„å­é—®é¢˜æ¥æ›´æ–°å˜é‡ x å’Œæ¾å¼›å˜é‡ sã€‚

4ã€**æ›´æ–°å‚æ•°**ï¼šå‡å°éšœç¢å‚æ•° Î¼ï¼Œå¹¶æ›´æ–° xå’Œ sã€‚

5ã€**æ”¶æ•›æ€§æ£€æŸ¥**ï¼šæ£€æŸ¥æ˜¯å¦æ»¡è¶³æ”¶æ•›æ ‡å‡†ï¼ˆå¦‚æ¢¯åº¦çš„å¤§å°ã€çº¦æŸçš„è¿åç¨‹åº¦ç­‰ï¼‰ã€‚å¦‚æžœæ”¶æ•›ï¼Œåœæ­¢è¿­ä»£ï¼›å¦åˆ™ï¼Œè¿”å›žæ­¥éª¤ 2ã€‚



åœ¨ä»£ç æ®µä¸­ï¼Œéœ€è¦å¯¹IPOPTè¿›è¡Œè®¾ç½®ï¼Œå¹¶è®¾ç½®æ±‚è§£å™¨

```
# ipoptè®¾ç½®:
# ipopt.max_iter: æœ€å¤§è¿­ä»£æ¬¡æ•°
# ipopt.print_level: è¾“å‡ºä¿¡æ¯çš„è¯¦ç»†çº§åˆ«ï¼Œ0 è¡¨ç¤ºå…³é—­è¾“å‡º
# print_time: æŽ§åˆ¶æ˜¯å¦è¾“å‡ºæ±‚è§£æ—¶é—´
# ipopt.acceptable_tol: æŽ¥å—çš„KKTå€¼çš„å®¹å¿åº¦
# ipopt.acceptable_obj_change_tol: æŽ¥å—çš„ç›®æ ‡å‡½æ•°å˜åŒ–çš„å®¹å¿åº¦
opts_setting = {'ipopt.max_iter': 1000, 'ipopt.print_level': 0, 'print_time': 0, 'ipopt.acceptable_tol': 1e-8,'ipopt.acceptable_obj_change_tol': 1e-8}
```

å…¶ä¸­'acceptable_tol'ä¸ºå¯æŽ¥å—çš„æœ€ä¼˜æ€§å®¹å¿åº¦ï¼ˆacceptable toleranceï¼‰ï¼Œå½“ KKTï¼ˆKarush-Kuhn-Tuckerï¼‰æ¡ä»¶çš„æ®‹å·®ï¼ˆè¯¯å·®ï¼‰å°äºŽæˆ–ç­‰äºŽè¿™ä¸ªå€¼æ—¶ï¼ŒIPOPT ä¼šè®¤ä¸ºå½“å‰è§£å·²ç»è¶³å¤Ÿå¥½ï¼Œå¯ä»¥æŽ¥å—ä¸ºä¸€ä¸ªå¯è¡Œè§£æˆ–æ¬¡ä¼˜è§£ã€‚è¿™ä¸ªå‚æ•°ç”¨äºŽè®¾ç½® IPOPT ä½•æ—¶è®¤ä¸ºæ‰¾åˆ°ä¸€ä¸ªâ€œè¶³å¤Ÿå¥½â€çš„è§£ï¼Œå¯ä»¥åœ¨æŸäº›æƒ…å†µä¸‹æå‰ç»ˆæ­¢ä¼˜åŒ–è¿‡ç¨‹ã€‚è®¾ç½®ä¸€ä¸ªè¾ƒå°çš„å€¼æ„å‘³ç€ç®—æ³•è¦æ±‚æ›´é«˜çš„ç²¾åº¦ï¼Œè€Œè¾ƒå¤§çš„å€¼åˆ™æ„å‘³ç€ç®—æ³•å¯ä»¥åœ¨æ›´ä½Žç²¾åº¦ä¸‹ç»ˆæ­¢ã€‚

'acceptable_obj_change_tol'ä¸ºå¯æŽ¥å—çš„ç›®æ ‡å‡½æ•°å˜åŒ–å®¹å¿åº¦ï¼ˆacceptable objective change toleranceï¼‰ï¼Œå½“è¿žç»­ä¸¤æ¬¡è¿­ä»£ä¹‹é—´çš„ç›®æ ‡å‡½æ•°å€¼å˜åŒ–å°äºŽæˆ–ç­‰äºŽè¿™ä¸ªå€¼æ—¶ï¼ŒIPOPT ä¼šè®¤ä¸ºç›®æ ‡å‡½æ•°å€¼å·²ç»è¶³å¤Ÿç¨³å®šï¼Œå¯ä»¥æŽ¥å—å½“å‰è§£ä¸ºä¸€ä¸ªå¯è¡Œè§£æˆ–æ¬¡ä¼˜è§£ã€‚



æœ€ç»ˆå¯ä»¥å¾—åˆ°æ±‚è§£å™¨ï¼š

```
# solver' æ˜¯æ±‚è§£å™¨çš„åç§°
# ipopt' æŒ‡å®šäº†æ‰€ä½¿ç”¨çš„æ±‚è§£å™¨ä¸º IPOPT
# nlp_prob æ˜¯å®šä¹‰å¥½çš„éžçº¿æ€§ä¼˜åŒ–é—®é¢˜
# opts_setting æ˜¯æ±‚è§£å™¨çš„è®¾ç½®å‚æ•°ï¼Œå‘Šè¯‰æ±‚è§£å™¨å¦‚ä½•è¿›è¡Œæ±‚è§£
solver = ca.nlpsol('solver', 'ipopt', nlp_prob, opts_setting)
```



### 2.3 ä»¿çœŸè¿‡ç¨‹

åœ¨å¼€å§‹ä»¿çœŸçš„è¿‡ç¨‹ä¸­ï¼Œå…ˆè®¾ç½®å¯¹æŽ§åˆ¶æ¡ä»¶çš„çº¦æŸï¼š

```
control_max = ca.pi
lbx = []  # æœ€ä½Žçº¦æŸæ¡ä»¶
ubx = []  # æœ€é«˜çº¦æŸæ¡ä»¶
for _ in range(N):
    #   åœ¨ä¸€ä¸ªå¾ªçŽ¯é‡Œè¿›è¡Œè¿žç»­å®šä¹‰
    lbx.append(-control_max)
    ubx.append(control_max)

```

åœ¨å¯¹ä»¿çœŸæ‰€éœ€çš„å‚æ•°ä½œè¿›ä¸€æ­¥çš„è®¾ç½®ï¼š

```
# ä»¿çœŸæ¡ä»¶å’Œç›¸å…³å˜é‡
t0 = 0.0  # ä»¿çœŸå¼€å§‹æ—¶é—´
x0 = np.array([1.5, 0.5, 0.0]).reshape(-1, 1)  # åˆå§‹å§‹çŠ¶æ€
xs = np.array([0.5, 0.5, np.nan]).reshape(-1, 1)  # æœ«çŠ¶æ€ï¼Œå¯¹æœ«çŠ¶æ€çš„æ—¶é—´æ¡ä»¶ä¸ä½œè¦æ±‚
u0 = np.array([0.0] * N).reshape(-1, n_controls)  # ç³»ç»Ÿåˆå§‹æŽ§åˆ¶çŠ¶æ€ï¼Œä¸ºäº†ç»Ÿä¸€æœ¬ä¾‹ä¸­æ‰€æœ‰numpyæœ‰å…³,Nè¡Œ,n_controlsåˆ—,æ¯ä¸ªå€¼éƒ½æ˜¯0ï¼ŒNä¸ºå¼€å§‹æ—¶è®¾å®šçš„è¦é¢„æµ‹çš„æ­¥æ•°
# å˜é‡éƒ½ä¼šå®šä¹‰æˆï¼ˆN,çŠ¶æ€æ•°ï¼‰çš„å½¢å¼æ–¹ä¾¿ç´¢å¼•å’Œprint
x_c = []  # å­˜å‚¨ç³»ç»Ÿçš„çŠ¶æ€
position_record = []  # è®°å½•åæ ‡ä½ç½®
u_c = []  # å­˜å‚¨æŽ§åˆ¶å…¨éƒ¨è®¡ç®—åŽçš„æŽ§åˆ¶æŒ‡ä»¤
t_c = []  # ä¿å­˜æ—¶é—´
xx = []  # å­˜å‚¨æ¯ä¸€æ­¥ä½ç½®
sim_time = 20  # ä»¿çœŸæ—¶é•¿
index_t = []  # å­˜å‚¨æ—¶é—´æˆ³ï¼Œä»¥ä¾¿è®¡ç®—æ¯ä¸€æ­¥æ±‚è§£çš„æ—¶é—´
```



å®Œæˆä¸Šè¿°è®¾å®šåŽï¼Œå®Œæ•´çš„ä»¿çœŸè¿‡ç¨‹å¦‚ä¸‹ï¼š

```
def shift_movement(delta_t, t_in, x_in, u, function):
    # è¿åŠ¨åˆ°ä¸‹ä¸€ä¸ªçŠ¶æ€
    f_value = function(x_in, u[:, 0])
    st = x_in + delta_t * f_value
    # æ—¶é—´å¢žåŠ 
    t_move = t_in + delta_t
    # å‡†å¤‡ä¸‹ä¸€ä¸ªä¼°è®¡çš„æœ€ä¼˜æŽ§åˆ¶
    # æ›´æ–°æŽ§åˆ¶è¾“å…¥çŸ©é˜µï¼ŒåŽ»æŽ‰ç¬¬ä¸€åˆ—æŽ§åˆ¶è¾“å…¥ï¼Œåœ¨æœ«å°¾æ·»åŠ ä¸Šï¼ˆå¤åˆ¶ï¼‰æœ€åŽä¸€åˆ—æŽ§åˆ¶è¾“å…¥
    u_end = ca.horzcat(u[:, 1:], u[:, -1])
    return t_move, st, u_end.T
```



```
# 6 å¼€å§‹ä»¿çœŸ
mpciter = 0  # è¿­ä»£è®¡æ•°å™¨
start_time = time.time()  # èŽ·å–å¼€å§‹ä»¿çœŸæ—¶é—´
# ç»ˆæ­¢æ¡ä»¶ä¸ºç›®æ ‡çš„æ¬§å¼è·ç¦»å°äºŽD/6æˆ–è€…ä»¿çœŸè¶…æ—¶
while np.linalg.norm(x0[:2] - xs[:2]) > D / 20 and mpciter - sim_time / dt < 0.0:
    print("'''''''''''''''''''''''''")
    print("mpc_iter", mpciter)
    print("æŽ§åˆ¶å™¨è¾“å…¥", u0)
    # åˆå§‹åŒ–ä¼˜åŒ–å‚æ•°
    # c_pä¸­å­˜å‚¨çš„æ˜¯å½“å‰çš„ä½ç½®ä¿¡æ¯å’Œç›®æ ‡ç‚¹çš„ä½ç½®ä¿¡æ¯ï¼Œå¯¹åº”å‡½æ•°è®¾å®šä¸­çš„PçŸ©é˜µ
    c_p = np.concatenate((x0, xs))
    # åˆå§‹åŒ–ä¼˜åŒ–ç›®æ ‡å˜é‡
    init_control = ca.reshape(u0, -1, 1)
    # è®¡ç®—ç»“æžœå¹¶ä¸”
    t_ = time.time()
    # æ±‚è§£å™¨å¾—åˆ°æŽ§åˆ¶è¾“å‡º
    res = solver(x0=init_control, p=c_p, lbx=lbx, ubx=ubx)
    index_t.append(time.time() - t_)
    # èŽ·å¾—æœ€ä¼˜æŽ§åˆ¶ç»“æžœu
    u_sol = ca.reshape(res['x'], n_controls, N)  # è®°ä½å°†å…¶æ¢å¤Uçš„å½¢çŠ¶å®šä¹‰
    # æ¯ä¸€åˆ—ä»£è¡¨äº†ç³»ç»Ÿåœ¨æ¯ä¸ªæ—¶é—´æ­¥ä¸Šçš„æœ€ä¼˜æŽ§åˆ¶è¾“å…¥
    # åˆ©ç”¨ä¹‹å‰å®šä¹‰ffå‡½æ•°èŽ·å¾—æ ¹æ®ä¼˜åŒ–åŽçš„ç»“æžœ
    ff_value = ff(u_sol, c_p)  
    # ä¹‹åŽN+1æ­¥åŽçš„çŠ¶æ€ï¼ˆn_states, N+1ï¼‰
    # å­˜å‚¨ç»“æžœ
    x_c.append(ff_value)
    u_c.append(u_sol[:, 0])
    t_c.append(t0)
    # æ ¹æ®æ•°å­¦æ¨¡åž‹å’ŒMPCè®¡ç®—çš„ç»“æžœç§»åŠ¨å¹¶ä¸”å‡†å¤‡å¥½ä¸‹ä¸€ä¸ªå¾ªçŽ¯çš„åˆå§‹åŒ–ç›®æ ‡
    t0, x0, u0 = shift_movement(dt, t0, x0, u_sol, f)
    # å­˜å‚¨ä½ç½®
    x0 = ca.reshape(x0, -1, 1)
    xx.append(x0.full())
    position_record.append([x0.full()[0], x0.full()[1]])
    # æ‰“å°çŠ¶æ€å€¼
    print("Current State:", x0.full())
    # è®¡æ•°å™¨+1
    mpciter = mpciter + 1
```



## 3 è¾“å‡ºç»“æžœ

è°ƒæ•´é¢„æµ‹çš„æ­¥æ•°Nï¼Œå¯ä»¥å¾—åˆ°æƒ³è¦è¾“å‡ºçš„ç»“æžœï¼š

![MPC-output](C:\Users\LENOVO\Desktop\Double-Gyre-Flow\MPCæŽ§åˆ¶æ–¹æ³•\MPC-output.png)
